# 程式執行與記憶體管理
*MMU*：記憶體管理單元

1. 單一程式
	同時 <mark>僅能一個</mark> 程式存在記憶體內 <mark>單獨執行</mark>，程式輸出輸入時CPU閒置，MMU功能簡單，但記憶體與CPU使用率低
2. 多重程式
	同時 <mark>允許多個</mark> 程式存在記憶體內 <mark>並行執行</mark>，CPU在多個程式間快速切換，MMU功能複雜，可用技術如下：
	1. 非置換 (Non-swapping)：程式執行期間須完整留在記憶體中，不能置換，有分割 (<mark>連續配置</mark>)，簡單分頁分段 (<mark>不連續配置</mark>)，夥伴系統
	2. 可置換 (Swapping)：程式執行期間可在記憶體與硬碟間相互置換，載入部分程式即可執行，又稱 <mark>虛擬記憶體</mark>。如分頁，分段


# 非置換 (Non-swapping)記憶體技術
1. 連續記憶體配置：
	1. 固定分割：將記憶體分成多個固定or變動大小的靜態區塊 (<mark>分割後，區塊大小不變</mark>)，一個行程使用一個區塊
	2. 動態分割：OS 依行程需求，配置夠大的可用區塊，記憶體空間使用效率高
2. 不連續記憶體配置：
	1. 簡單分頁 (Paging)：行程切成固定大小稱 <mark>分頁</mark>，主記憶體切成同大小稱 <mark>頁框</mark>，由OS 負責將行程分頁載入到可用頁框；無外部破碎問題，但有內部破碎問題
		1. 頁框表：OS 管理實體記憶體所需的資料結構，可記錄每個頁框配置情形，如總頁框數，以配置頁框，可用頁框。
		2. 分頁表：<mark>行程獨有</mark>，紀錄該行程所有分頁與頁框之間的對應關係，2 種實作方式
			1. 分頁表存 <mark>暫存器內</mark>：位址轉換速度快，分頁表大小受限+內文切換速度慢
			2. 分頁表存 <mark>主記憶體</mark>：內文切換速度快+大型分頁表使用，位址轉換速度慢

		3. 存取記憶體時，邏輯位址需轉換成實體位址，才能正確存取資料
		4. 反轉分頁表：紀錄實體頁框與行程分頁的對應關係，<mark>只有一個</mark>，可改善分頁表浪費記憶體空間的問題
	2. 簡單分段 (Segmentation)：無內部破碎，但有外部破碎問題
	3. AMAT：快取時間+TLB失誤率x記憶體時間+記憶體時間

# 可置換 (Swapping)記憶體技術 A.K.A 虛擬記憶體
行程先存硬碟，執行時由MMU <mark>部分載入</mark> DRAM內之記憶體管理技術
1. 允許行程使用超過實體記憶體大小的位址空間，簡化大型程式設計
2. 可增加系統多工程度，提升CPU的使用率和工作量
3. 與行程執行時需完全載入相比，載入資料量少，啟動時間變快
4. 不同行程的虛擬位址，可映射到相同的實體位址，以共享記憶體內容，如共用標準含事庫或行程間通訊

## 需求分頁
分頁法變形，分頁先存硬碟，需求時 (<mark>分頁不在主記憶體，分頁錯誤，Page Fault</mark>) 才以分頁程式 (<mark>Pager，又稱懶惰置換程式，Lazy Swapper</mark>) 載入
存取時間分析：
<mark>EMAT：(1-錯誤率) x 記憶體存取時間 + 錯誤率 x 記憶體存取時間</mark>
分頁置換策略：
1. 最佳策略：Optimal，選未來最久不會參考的分頁
	1. 優：分頁錯誤率低，效能佳
	2. 缺：未來不可全知，難實作
2. 先進先出：FIFO，選最先載入的分頁 (比載入時間)
	1. 優：實作容易
	2. 缺：有必雷地異常&效能差
3. 近來無用：LRU，選過去最久無存取的分頁 (比最後存取時間)
	1. 優：過去已知，可實作，近似最佳策略
	2. 缺：需硬體輔助，如計數器/堆疊，計入各分頁的使用時間

<mark>必雷地 (Belady's phenomenon)：在使用FIFO分頁置換策略時，頁框增加，卻造成分頁錯誤次數也增加的異常現象</mark>

## 需求分段
分段法變形，分段先存硬碟，需求時才載入，分段表可增加有效—無效、修改、保護與共享位元

[回到索引]((%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E7%B4%A2%E5%BC%95))